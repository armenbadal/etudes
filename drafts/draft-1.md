# Ստեկային լեզվի ինտերպրետատոր

Այս առաջադրանքում պահանջվում է նախագծել և իրականացնել մի ծրագրավորման
լեզու, որի ինտերպրետացիան հիմնված է *ստեկ* կառուցվածքի օգտագործման վրա։
Այդ լեզուն կանվանենք *ստեկային լեզու*։

Կան երկու հրամաններ, որոնք պատմականորեն կապված են ստեկի հետ։ Դրանցից
մեկը `PUSH` հրամանն է, որն իր արգումենտում տրված փոփոխականի կամ
հաստատունի արժեքն ավելացնում է ստեկում։ Մյուսը `POP` հրամանն է, որը
հեռացնում է ստեկի գագաթի արժեքը և այն վերագրում է իր արգումենտում տրված
փոփոխականին։

Տվյալների ներածման `IN` հրամանը ստանդարտ ներածման հոսքից կարդում է մեկ
թիվ և այն գրում է ստեկում։ Իսկ արտածման `OUT` հրամանը հեռացնում է ստեկի
գագաթի տարրը և այն տպում է ստանդարտ արտածման հոսքին։

Թվաբանական գործողությունների համար նախատեսենք ամբողջ թվերի հետ
գործողություններ կատարող մի քանի հրամաններ.

::: center
::: small
  ------- ------------------- ------- -----------
  `ADD`   Գումարում,          `SUB`   Հանում
  `MUL`   Բազմապատկում,       `DIV`   Բաժանում
  `MOD`   Մնացորդի որոշում,   `NEG`   Բացասում։
  ------- ------------------- ------- -----------
:::
:::

Այս հրամաններից ոչ մեկն արգումենտ չունի։ Դրանցից ամեն մեկը ստեկից հանում
է իր պատիկության քանակով արժեքներ, կատարում է համապատասխան
գործողությունը և արդյունքը հետ է գրում ստեկում։ Օրինակ,
«$a\,\mathbf{:=}\, -3 + b$» վերագրումը կատարելու համար պետք է գրել
հետևյալը.

``` {xleftmargin="1in"}
PUSH 3
NEG
PUSH b
ADD
POP a
```

Նույն կերպ են աշխատում նաև համեմատման գործողությունները՝ ստեկի գագաթում
որպես արդյունք թողնելով բուլյան **True** և **False** արժեքներին
համապատասխանող $1$ և $0$ թվերը։

::: center
  ------ ------------ ------ ---------------------
  `EQ`   Հավասար է,   `NE`   Հավասար չէ,
  `GT`   Մեծ է,       `GE`   Մեծ է կամ հավասար,
  `LT`   Փոքր է,      `LE`   Փոքր է կամ հավասար։
  ------ ------------ ------ ---------------------
:::

Տրամաբանական գործողությունները ստեկի զրոյական արժեքը մեկնաբանում են
որպես **False**, իսկ ոչ զրոյականները՝ **True**։

::: center
::: small
  ----- ------------------------------
  AND   Տրամաբանական **ԵՎ**,
  OR    Տրամաբանական **ԿԱՄ**,
  NOT   Տրամաբանական ժխտում՝ **ՈՉ**։
  ----- ------------------------------
:::
:::

Ծրագրի ընթացքը ղեկավարելու համար կօգտագործենք *նշիչների* (label) և
*անցումների* (jump) մեխանիզմը։ Մեր ստեկային լեզվի ամեն մի հրաման կարող է
ունենալ նշիչ, որն իդենտիֆիկատոր է և գրվում է հրամանից առաջ։ Նշիչը
հրամանից առանձնանում է «`:`» նիշով։

Նշիչին կարելի է անցում կատարել `JUMP`, `JZ` և `JNZ` հրամաններով.

::: center
::: small
  -------------- ---------------------------------------------------------
  `JUMP label`   Առանց պայմանի նցում `label` նշիչին,
  `JZ label`     Անցնել `label` նշիչին, եթե ստեկի գագաթի տարրը *զրո է*,
  `JNZ label`    Անցնել `label` նշիչին, եթե ստեկի գագաթի տարրը *զրո չէ*,
  `HALT`         Ավարտել ծրագրի կատարումը:
  -------------- ---------------------------------------------------------
:::
:::

Որպես ստեկային լեզվի կիրառության օրինակ դիտարկենք երկու թվերի ամենամեծ
ընդհանուր բաժանարարը որոշող Էվկլիդեսի ալգորիթմը։

``` {xleftmargin="1in"}
IN
      POP a
      IN 
      POP b
w0:   PUSH a
      PUSH b
      MUL
      JZ p0
      PUSH a
      PUSH b
      GT
      JZ el0
      PUSH a
      PUSH b
      SUB
      POP a
      JUMP eif0
el0:  PUSH b
      PUSH a
      SUB
      POP b
eif0: NOP
      JUMP w0
p0:   PUSH a
      PUSH b
      ADD
      OUT
      HALT
```

# Թվային հիշող սարքի մոդել և տեստավորման լեզու

Թվային հիշող սարքի պարզեցված ծրագրային մոդելը կարող ենք ներկայացնել $C$
հատ սյուներից և $R$ հատ տողերից բաղկացած *բջիջների* մատրիցի տեսքով,
որտեղ ամեն մի բջջում կարելի է գրել մեկ *բիթ* ինֆորմացիա՝ $0$ կամ $1$։
Պարզության համար կդիտարկենք այնպիսի մոդել, որտեղ մեկ գործողությամբ
կարելի է գրել կամ կարդալ մատրիցի միայն մեկ բջիջը։ Գրելու գործողությունը
կատարվում է $\mathrm{write}(address, data)$ պրոցեդուրայով, իսկ կարդալու
գործողությունը՝ $\mathrm{read}(address)$ պրոցեդուրայով։ $address$-ը բջջի
գծային (տրամաբանական) հասցեն է, որն ընկած է ամբողջ թվերի $[0;C\times R)$
միջակայքում։

![Թվային հիշող սարքի սխեման](etupic-1.pdf)

Իդեալական դեպքում ապարատային թվային հիշող սարքը պետք է աշխատի առանց
սխալների։ Բայց տարբեր տեխնոլոգիական պատճառներով շատ հաճախ են հանդիպում
այնպիսի դեպքեր, երբ հիշող բջիջը չի աշխատում նախագծվածի պես, կամ
հասցեների դեկոդերը կատարում է տողերի ու սյուների հասցեների սխալ
արտապատկերում։ Հիշող սարքերի ծրագրային մոդելներն օգտագործվում են
բազմազան սխալներ մոդելավորելու և այդ սխալները որսացող ալգորիթմներ
մշակելու համար։

Թվային հիշող սարքի տեստավորման ժամանակ օգտագործվում են երկու
պրոցեդուրաներ՝ `W` և `R`, որոնք տեստավորման տերմինաբանության մեջ կոչվում
են *march* գործողություններ։ Առաջինը ֆունկցիան ընթացիկ բջջում գրում է
տրված արժեքը, իսկ երկրորդ ֆունկցիան կարդում է բջջի արժեքը և համեմատում է
իր արգումենտում տրված արժեքի հետ։ Օրինակ, ունենք մի մատրից, որի
բջիջներից մեկը փչացած է, և անսարքությունն արտահայտվում է նրանով, որ
կարդալու `read` գործողությունը միշտ վերադարձնում է նույն $0$ արժեքը։ Այս
անսարքությունը որսալու համար կարող ենք հիշող սարքի մատրիցի բոլոր
բջիջներում գրել $1$ արժեքը, ապա կատարել կարդալու գործողություն՝
ակնկալելով $1$ արժեք։

Նշելու համար, որ march գործողությունների որևէ հաջորդականություն պետք է
կատարել հիշող սարքի բոլոր բջիջների համար, կազմվում են *march տարրեր*
(element)։ March տարրը ցույց է տալիս նաև, թե բջիջների անցման ինչ
հաջորդականություն պետք է ընտրել՝ աճող հասցեներ, թե՝ նվազող հասցեներ։
Օրինակ, եթե դիտարկում ենք $N = C\times R$ բջիջներից բաղկացած հիշող սարք,
ապա $\Uparrow(W1, R1)$ march տարրը ցույց է տալիս, որ սկսած $0$ հասցեից
մինչև $N-1$ հասցեն, հերթական բջջում գրել $1$ արժեքը՝ $W1$, ապա կարդալ
գրված արժեքը՝ ակնկալելով $1$՝ $R1$։ Պարզ է, որ եթե մի որևէ բջջից,
անսարքության պատճառով, միշտ կարդացվում է $1$ արժեքը, ապա այս march տարրի
կատարումը կձախողվի հենց այդ բջջի հասցեի վրա։ Եթե հարկավոր է բջիջները
թվարկել $N-1$-ից մինչև $0$ հասցեները, ապա march տարրի գրառման մեջ
«$\Uparrow$» սլաքը պետք է փոխարինել «$\Downarrow$» սլաքով։

March տարրերի խումբը, որ պետք է հաջորդաբար կիրառել հիշող սարքի բջիջների
նկատմամբ, կանվանենք *maarch ալգորիթմ* և ամեն մի ալգորիթմին կտանք հեշտ
հիշվող և ալգորիթմի բնույթը նկարագրող անուն։

::: center
::: small
  ----------- --- -------------------------------------------------
      Program  =  Algorithm .
    Algorithm  =  'Algorithm' IDENT '' Element ';' Element ''.
      Element  =  ('-\>'\|'\<-') '(' Operation ',' Operation ')'.
    Operation  =  R0 \| R1 \| W0 \| W1.
  ----------- --- -------------------------------------------------
:::
:::

# Վերջավոր ավտոմատների լեզու

Որպեսզի ավելի հստակ պատկերացնենք, թե ինչ բաղադրիչներ է ունենալու
ավտոմատների նկարագրման լեզուն, նախ հիշենք վերջավոր ավտոմատի
մաթեմատիկական սահմանումը։ $M$ *վերջավոր ավտոմատը* սահմանվում է որպես $Q$
*վիճակների* բազմությամբ, $\Sigma$ *այբուբենով*,
$\delta:Q\times\Sigma\to Q$ *անցումների* ֆունկցիայով, $q_0\in Q$
*սկզբնական* վիճակով և $F\subseteq Q$ *վերջնական* վիճակների բազմությամբ
մի հնգյակ՝ $M=\langle Q,\Sigma,\delta,q_0,F\rangle$։

Այս սահմանումից օգտվելով կարելի է առաջարկել վերջավոր ավտոմատի
նկարագրության հետևյալ քերականությունը.

::: center
::: small
  ---------- --- --------------------------------------------------------------------------
    Automata  =  **Automata** 'Ident' '**{**' States Alphabet Start Finals Delta '**}**'.
      States  =  **States** '**=**' '**{**' 'Ident' {'**,**' 'Ident'} '**}**'.
    Alphabet  =  **Alphabet** '**=**' '**{**' 'Char' {'**,**' 'Char'} '**}**'.
       Start  =  **Start** '**=**' 'Ident'.
      Finals  =  **Finals** '**=**' '**{**' 'Ident' {'**,**' 'Ident'} '**}**'.
       Delta  =  **Delta** '**=**' '**{**' \... '**}**'.
              =  '**(**' 'Ident' '**,**' 'Char' '**)**' '**-\>**' 'Ident'.
  ---------- --- --------------------------------------------------------------------------
:::
:::

Օրինակ,

![$1(01)*$ արտահայտության ավտոմատը](etupic-2.pdf)

``` {xleftmargin="1in"}
Automata A0 {
  States = { s0, s1, s2 }
  Alphabet = { '0, '1 }
  Start = s0
  Finals = { s1 }
  Delta = {
    (s0, '1) -> s1,
    (s1, '0) -> s2,
    (s2, '1) -> s1
  }
}
```

Բացի ավտոմատի նկարագրությունը, լեզուն պետք է հնարավորություն տա որևէ տող
«ճանաչել» սահմանված ավտոմատով։ Այդ նպատակի համար սահմանենք `Recognize`
հրամանը՝ հետևյալ քերականությամբ։

::: center
::: small
  ----------- --- ------------------------------------------
    Recognize  =  **Recognize** 'String' **With** 'Ident'.
  ----------- --- ------------------------------------------
:::
:::

Իսկ մեր ամբողջ ծրագիրը կարող է բաղկացած լինե `Automata`
հայտարարություններից և `Recognize` հրամաններից.

::: center
::: small
  -------- --- ----------------------------
    Script  =  { Automata \| Recognize }.
  -------- --- ----------------------------
:::
:::

Լուծումներ և ուղղությունների նշումներ

Առաջադրանքներ

# Ռելյացիոն հանրահաշվի լեզու

Իրականացնել տվյալների բազաների ռելյացիոն հանրահաշվի լեզվի թարգմանիչ, որն
իր մուտքում տրված ծրագիրը թարգմանում է SQL-ի։

Հարաբերության սահմանումը, հարաբերության սխեմա։ Ռելյացիոն հանրահաշիվ,
գործողությունները։

::: center
::: small
  ---------------- ---- -------------------------------------------------------------------
             Query  =   SecondaryQuery.
    SecondaryQuery  =   PrimaryQuery { SetOperation PrimaryQuery }.
      PrimaryQuery  =   Relation
                    \|  "`(`" SecondaryQuery "`)`"
                    \|  "$\pi$" "`{`" ArgumentList "`}`" \"(\" SecondaryQuery \")\"
                    \|  \"$\rho$\" \"{\" Relation \"}\" \"(\" SecondaryQuery \")\"
                    \|  \"$\sigma$\" \"{\" Predicate \"}\" \"(\" SecondaryQuery \")\".
          Realtion  =   \"Identifier\" \[ \"(\" ArgumentList \")\" \].
      SetOperation  =   "$\cup$" \| "$\setminus$" \| "$\cap$" \| "$\times$" \| "$join$".
      ArgumentList  =   \"Identifier\" { \",\" \"Identifier\" }.
         Predicate  =   Disjunction.
       Disjunction  =   Conjunction { \"@or\" Conjunction }.
       Conjunction  =   Equality { \"@and\" Equality }.
          Equality  =   Inequality \[ (\"=\" \| \"\<\>\" Inequality \].
        Inequality  =   Negation \[ (\"\>\" \| \"\>=\" \| \"\<\" \| \"\<=\") Negation \].
          Negation  =   \[\"@not\"\] Factor.
            Factor  =   \"Identifier\"
                    \|  \"(\" Disjunction \")\"
                    \|  \"String\"
                    \|  \"Number\".
  ---------------- ---- -------------------------------------------------------------------
:::
:::

# Պատկերների կառուցման լեզու

Գրաֆիկական պրիմիտիվներ։ Գործողություններ։ Մակրոսներ։

# Հանրահաշվական բազմանդամների լեզու

Հանրահաշվական բազմանդամ։

## Տրամաբանական սխեմաների սիմուլյատոր

Նախագծել ու իրականացնել տրամաբանական սխեմաների նկարագրման լեզու և ինտերպրետատոր (կամ տրանսլյատոր, օրինակ, C լեզվի)։ Լեզուն պետք է թույլ տա սխեմաներ կառուցել {AND, OR, NOT} բազիսով։ Ինտերպրետատորը (կամ տրանսլյատորը) պետք է հնարավորություն տան տրված մուտքային ազդանշանների համար հաշվարկել սխեմայի ելքային արժեքները։ Նոր սահմանվող տրամաբանական միավորներն իրականացնել որպես (հիգիենիկ) մակրոսներ։

{AND, OR, NOT} բազիսի գործողությունները պետք է իրականացվեն որպես լեզվի ներդրված գործողություններ։ Տրամաբանական արտահայտությունների գրառումը պարզեցնելու համար լեզուն պետք է ունենա մի գործողություն, որը պահում է միջանկյալ արժեքներ։

Այս խնդրի հետաքրքիր ընդլայնում կարող է լինել գրաֆիկական խմբագրիչի ստեղծումը։ Օգտագործողը պետք է կարողանա տրամաբանական սխեմաներ ու դրանց գրադարաններ կառուցել տրամաբանական տարրերն իրար միացնելով։

Քերականությունը

```
Module = [NewLines] { Scheme NewLines }.
Scheme = SCHEME IDENT IdentList '->' IdentList NewLines
     	{ Operation NewLines } END IDENT.
NewLines = NL { NL }.
Operation = IDENT FactorList '->' IdentList.
FactorList = Factor { Factor }.
IdentList = IDENT { IDENT }.
Factor = IDENT | 'T' | 'F'.
```

Տերմինալային սիմվոլների բազմությունը. 'T', 'F', IDENT, '->', 'SCHEME', 'END', NL
